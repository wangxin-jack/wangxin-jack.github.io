<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.62.2" />
  
  
  
  <title>
    
    Hugo Theme Yuki
    
  </title>
  <link rel="canonical" href="https://wangxin-jack.github.io/">
  
  <link rel="alternate" type="application/rss+xml" href="https://wangxin-jack.github.io/index.xml" title="Hugo Theme Yuki">
  
  
  
  
  
  
  































  
  <link rel="stylesheet" href="https://wangxin-jack.github.io/css/base.min.b7794e36de540988c929f5b91c2250c0ee81952f43bd68f7e234d8e7e128b3ca.css" integrity="sha256-t3lONt5UCYjJKfW5HCJQwO6BlS9DvWj34jTY5&#43;Eos8o=" crossorigin="anonymous">
  
  
</head>
<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <a class="Banner-link u-clickable" href="https://wangxin-jack.github.io/">Hugo Theme Yuki</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://wangxin-jack.github.io/">HOME</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://wangxin-jack.github.io/post">BLOG</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://wangxin-jack.github.io/about">ABOUT</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://wangxin-jack.github.io/tags/">TAGS</a>
      </li>
      
    </ul>
  </div>
</nav>

  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        



<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://wangxin-jack.github.io/2017/11/08/istio-canary-release/" rel="bookmark">采用Istio实现灰度发布(金丝雀发布)</a>
  </h2>
  
  <time datetime="2017-11-08T15:00:00Z">
    8 November, 2017
  </time>
  
</header>

  
  <h2 id="灰度发布又名金丝雀发布介绍">灰度发布（又名金丝雀发布）介绍</h2>
<p>当应用上线以后，运维面临的一大挑战是如何能够在不影响已上线业务的情况下进行升级。做过产品的同学都清楚，不管在发布前做过多么完备的自动化和人工测试，在发布后都会出现或多或少的故障。根据墨菲定律，可能会出错的版本发布一定会出错。</p>
<p>&ldquo;ANYTHING THAN CAN GO WRONG WILL GO WRONG&rdquo;  &ndash;MURPHY'S LAW</p>
<p>因此我们不能寄希望于在线下测试时发现所有潜在故障。在无法百分百避免版本升级故障的情况下，需要通过一种方式进行可控的版本发布，把故障影响控制在可以接受的范围内，并可以快速回退。</p>
<p>可以通过<a href="https://martinfowler.com/bliki/CanaryRelease.html">灰度发布（又名金丝雀发布）</a>来实现业务从老版本到新版本的平滑过渡，并避免升级过程中出现的问题对用户造成的影响。</p>
<p>“金丝雀发布”的来源于矿工们用金丝雀对矿井进行空气测试的做法。以前矿工挖煤的时候，矿工下矿井前会先把金丝雀放进去，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用“金丝雀”来搞最先的测试。</p>
<p>下图中，左下方的少部分用户就被当作“金丝雀”来用于测试新上线的1.1版本。如果新版本出现问题，“金丝雀”们会报警，但不会影响其他用户业务的正常运行。
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-deployment.PNG" alt="Istio灰度发布示意图"></p>
<p>灰度发布（金丝雀发布）的流程如下：</p>
<ul>
<li>准备和生产环境隔离的“金丝雀”服务器。</li>
<li>将新版本的服务部署到“金丝雀”服务器上。</li>
<li>对“金丝雀”服务器上的服务进行自动化和人工测试。</li>
<li>测试通过后，将“金丝雀”服务器连接到生产环境，将少量生产流量导入到“金丝雀”服务器中。</li>
<li>如果在线测试出现问题，则通过把生产流量从“金丝雀”服务器中重新路由到老版本的服务的方式进行回退，修复问题后重新进行发布。</li>
<li>如果在线测试顺利，则逐渐把生产流量按一定策略逐渐导入到新版本服务器中。</li>
<li>待新版本服务稳定运行后，删除老版本服务。</li>
</ul>
<h2 id="istio实现灰度发布金丝雀发布的原理">Istio实现灰度发布(金丝雀发布)的原理</h2>
<p>从上面的流程可以看到，如果要实现一套灰度发布的流程，需要应用程序和运维流程对该发布过程进行支持，工作量和难度的挑战是非常大的。虽然面对的问题类似，但每个企业或组织一般采用不同的私有化实现方案来进行灰度发布,为解决该问题导致研发和运维花费了大量的成本。</p>
<p>Istio通过高度的抽象和良好的设计采用一致的方式解决了该问题，采用sidecar对应用流量进行了转发，通过Pilot下发路由规则，可以在不修改应用程序的前提下实现应用的灰度发布。</p>
<p>备注：采用kubernetes的<a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/">滚动升级(rolling update)</a>功能也可以实现不中断业务的应用升级,但滚动升级是通过逐渐使用新版本的服务来替换老版本服务的方式对应用进行升级，在滚动升级不能对应用的流量分发进行控制，因此无法采用受控地把生产流量逐渐导流到新版本服务中，也就无法控制服务升级对用户造成的影响。</p>
<p>采用Istio后，可以通过定制路由规则将特定的流量（如指定特征的用户）导入新版本服务中，在生产环境下进行测试，同时通过渐进受控地导入生产流量，可以最小化升级中出现的故障对用户的影响。并且在同时存在新老版本服务时，还可根据应用压力对不同版本的服务进行独立的缩扩容，非常灵活。采用Istio进行灰度发布的流程如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-deployments.gif" alt="Istio灰度发布示意图"></p>
<h2 id="操作步骤">操作步骤</h2>
<p>下面采用Istion自带的BookinfoInfo示例程序来试验灰度发布的流程。</p>
<h3 id="测试环境安装">测试环境安装</h3>
<p>首先参考<a href="http://zhaohuabing.com/2017/11/04/istio-install_and_example/">手把手教你从零搭建Istio及Bookinfo示例程序</a>安装Kubernetes及Istio控制面。</p>
<p>因为本试验并不需要安装全部3个版本的reviews服务，因此如果已经安装了该应用，先采用下面的命令卸载。</p>
<pre><code>istio-0.2.10/samples/bookinfo/kube/cleanup.sh
</code></pre><h3 id="部署v1版本的服务">部署V1版本的服务</h3>
<p>首先只部署V1版本的Bookinfo应用程序。由于示例中的yaml文件中包含了3个版本的reviews服务，我们先将V2和V3版本的Deployment从yaml文件istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml中删除。</p>
<p>从Bookinfo.yaml中删除这部分内容:</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: reviews-v2
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: reviews
        version: v2
    spec:
      containers:
      - name: reviews
        image: istio/examples-bookinfo-reviews-v2:0.2.3
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 9080
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: reviews-v3
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: reviews
        version: v3
    spec:
      containers:
      - name: reviews
        image: istio/examples-bookinfo-reviews-v3:0.2.3
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 9080    
---         
</code></pre><p>部署V1版本的Bookinfo程序。</p>
<pre><code>kubectl apply -f &lt;(istioctl kube-inject -f istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml)
</code></pre><p>通过kubectl命令行确认pod部署，可以看到只有V1版本的服务。</p>
<pre><code>kubectl get pods

NAME                              READY     STATUS    RESTARTS   AGE
details-v1-3688945616-nhkqk       2/2       Running   0          2m
productpage-v1-2055622944-m3fql   2/2       Running   0          2m
ratings-v1-233971408-0f3s9        2/2       Running   0          2m
reviews-v1-1360980140-0zs9z       2/2       Running   0          2m
</code></pre><p>在浏览器中打开应用程序页面，地址为istio-ingress的External IP。由于V1版本的reviews服务并不会调用rating服务，因此可以看到Product 页面显示的是不带星级的评价信息。</p>
<p><code>http://10.12.25.116/productpage</code><br>
<img src="/https://img.zhaohuabing.com/in-post/istio-canary-release/product-page-default.PNG" alt=""></p>
<p>此时系统中微服务的部署情况如下图所示（下面的示意图均忽略和本例关系不大的details和ratings服务）：
<img src="/https://img.zhaohuabing.com/in-post/istio-canary-release/canary-example-only-v1.PNG" alt=""></p>
<h3 id="部署v2版本的reviews服务">部署V2版本的reviews服务</h3>
<p>在部署V2版本的reviews服务前，需要先创建一条缺省路由规则route-rule-default-reviews.yaml，将所有生产流量都导向V1版本，避免对线上用户的影响。</p>
<pre><code>apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  name: reviews-default
spec:
  destination:
    name: reviews
  precedence: 1
  route:
  - labels:
      version: v1
</code></pre><p>启用该路由规则。</p>
<pre><code>istioctl create -f route-rule-default-reviews.yaml -n default
</code></pre><p>创建一个V2版本的部署文件bookinfo-reviews-v2.yaml，内容如下</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: reviews-v2
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: reviews
        version: v2
    spec:
      containers:
      - name: reviews
        image: istio/examples-bookinfo-reviews-v2:0.2.3
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 9080
</code></pre><p>部署V2版本的reviews服务。</p>
<pre><code>kubectl apply -f &lt;(istioctl kube-inject -f  bookinfo-reviews-v2.yaml)
</code></pre><p>此时系统中部署了V1和V2两个版本的reviews服务，但所有的业务流量都被规则reviews-default导向了V1，如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-example-deploy-v2.PNG" alt=""></p>
<h3 id="将测试流量导入到v2版本的reviews服务">将测试流量导入到V2版本的reviews服务</h3>
<p>在进行模拟测试时，由于测试环境和生产环境的网络，服务器，操作系统等环境存在差异，很难完全模拟生产环境进行测试。为了减少环境因素的对测试结果的影响，我们希望能在生产环境中进行上线前的测试，但如果没有很好的隔离措施，可能会导致测试影响已上线的业务，对企业造成损失。</p>
<p>通过采用Istio的路由规则，可以在类生产环境中进行测试，又完全隔离了线上用户的生产流量和测试流量，最小化模拟测试对已上线业务的影响。如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-example-route-test.PNG" alt=""></p>
<p>创建一条规则，将用户名为 test-user 的流量导入到V2</p>
<pre><code>apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  name: reviews-test-user
spec:
  destination:
    name: reviews
  precedence: 2
  match:
    request:
      headers:
        cookie:
          regex: &quot;^(.*?;)?(user=test-user)(;.*)?$&quot;
  route:
  - labels:
      version: v2
</code></pre><p>注意：precedence属性用于设置规则的优先级，在同时存在多条规则的情况下，优先级高的规则将先执行。这条规则的precedence设置为2，以确保其在缺省规则之前运行，将test-user用户的请求导流到V2版本reviews服务中。</p>
<p>启用该规则。</p>
<pre><code>istioctl create -f route-rule-test-reviews-v2.yaml -n default
</code></pre><p>以test-user用户登录，可以看到V2版本带星级的评价页面。
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/product-page-test-user.PNG" alt=""></p>
<p>注销test-user，只能看到V1版本不带星级的评价页面。如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/product-page-default.PNG" alt=""></p>
<h3 id="将部分生产流量导入到v2版本的reviews服务">将部分生产流量导入到V2版本的reviews服务</h3>
<p>在线上模拟测试完成后，如果系统测试情况良好，可以通过规则将一部分用户流量导入到V2版本的服务中，进行小规模的“金丝雀”测试。</p>
<p>修改规则route-rule-default-reviews.yaml，将50%的流量导入V2版本。</p>
<blockquote>
<p>备注：本例只是描述原理，因此为简单起见，将50%流量导入V2版本，在实际操作中，更可能是先导入较少流量，然后根据监控的新版本运行情况将流量逐渐导入，如采用5%，10%，20%，50% &hellip;的比例逐渐导入。</p>
</blockquote>
<pre><code>apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  name: reviews-default
spec:
  destination:
    name: reviews
  precedence: 1
  route:
  - labels:
      version: v1
    weight: 50
  - labels:
      version: v2
    weight: 50
</code></pre><pre><code>istioctl replace -f route-rule-default-reviews.yaml -n default
</code></pre><p>此时系统部署如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-example-route-production-50.PNG" alt=""></p>
<h3 id="将所有生产流量导入到到v2版本的reviews服务">将所有生产流量导入到到V2版本的reviews服务</h3>
<p>如果新版本的服务运行正常，则可以将所有流量导入到V2版本。</p>
<pre><code>apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  name: reviews-default
spec:
  destination: 
    name: reviews
  precedence: 1
  route:
  - labels:
      version: v2
    weight: 100
</code></pre><pre><code>istioctl replace -f route-rule-default-reviews.yaml -n default
</code></pre><p>系统部署如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/canary-example-route-production-100.PNG" alt=""></p>
<p>此时不管以任何用户登录，都只能看到V2版本带星级的评价页面，如下图所示：
<img src="https://img.zhaohuabing.com/in-post/istio-canary-release/product-page-default-v2.PNG" alt=""></p>
<blockquote>
<p>备注：如果灰度发布的过程中新版本的服务出现问题，则可以通过修改路由规则，将流量重新导入到V1版本的服务中，将V2版本故障修复后再进行测试。</p>
</blockquote>
<h3 id="删除v1版本的reviews服务">删除V1版本的reviews服务</h3>
<p>待V2版本上线稳定运行后，删除V1版本的reviews服务和测试规则。</p>
<pre><code>kubectl delete pod reviews-v1-1360980140-0zs9z

istioctl delete -f route-rule-test-reviews-v2.yaml -n default
</code></pre><h2 id="参考">参考</h2>
<ul>
<li><a href="https://istio.io/docs/">Istio官方文档</a></li>
</ul>

  
  






<footer>
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/categories/tech/" rel="tag">Tech</a>
    </li>
    
    
  </ul>
  
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/tags/istio/" rel="tag">Istio</a>
    </li>
    
    
  </ul>
  
  
</footer>


</article>
<div class="Divider"></div>

<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://wangxin-jack.github.io/2017/11/07/istio-traffic-shifting/" rel="bookmark">使用Istio实现应用流量转移</a>
  </h2>
  
  <time datetime="2017-11-07T00:00:00Z">
    7 November, 2017
  </time>
  
</header>

  
  <p>关于Istio的更多内容请参考<a href="http://istio.doczh.cn/">istio中文文档</a>。</p>
<p>原文参见<a href="https://istio.io/docs/tasks/traffic-management/traffic-shifting.html">Traffic Shifting</a>。</p>
<p>本任务将演示如何将应用流量逐渐从旧版本的服务迁移到新版本。通过Istio，可以使用一系列不同权重的规则（10%，20%，··· 100%）将流量平缓地从旧版本服务迁移到新版本服务。</p>
<p>为简单起见，本任务将采用两步将流量从<code>reviews:v1</code> 迁移到 <code>reviews:v3</code>，权重分别为50%，100%。</p>
<h1 id="开始之前">开始之前</h1>
<ul>
<li>
<p>参照文档<a href="http://istio.doczh.cn/docs/setup/kubernetes/index.html">安装指南</a>中的步骤安装Istio。</p>
</li>
<li>
<p>部署<a href="http://istio.doczh.cn/docs/guides/bookinfo.html">BookInfo</a> 示例应用程序。</p>
</li>
</ul>
<blockquote>
<p>请注意：本文档假设示采用kubernetes部署示例应用程序。所有的示例命令行都采用规则yaml文件（例如<code>samples/bookinfo/kube/route-rule-all-v1.yaml</code>）指定的kubernetes版本。如果在不同的环境下运行本任务，请将<code>kube</code>修改为运行环境中相应的目录（例如，对基于Consul的运行环境，目录就是<code>samples/bookinfo/consul/route-rule-all-v1.yaml</code>）。</p>
</blockquote>
<h1 id="基于权重的版本路由">基于权重的版本路由</h1>
<ol>
<li>
<p>将所有微服务的缺省版本设置为v1.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">istioctl create -f samples/bookinfo/kube/route-rule-all-v1.yaml
</code></pre></div></li>
<li>
<p>在浏览器中打开http://$GATEWAY_URL/productpage,  确认<code>reviews</code> 服务目前的活动版本是v1。</p>
<p>可以看到浏览器中出现BooInfo应用的productpage页面。
注意<code>productpage</code>显示的评价内容不带星级。这是由于<code>reviews:v1</code>不会访问<code>ratings</code>服务。</p>
<blockquote>
<p>请注意：如果之前执行过 <a href="http://istio.doczh.cn/docs/tasks/traffic-management/request-routing.html">配置请求路由</a>任务，则需要先注销测试用户“jason”或者删除之前单独为该用户创建的测试规则：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">istioctl delete routerule reviews-test-v2
</code></pre></div></li>
<li>
<p>首先，使用下面的命令把50%的流量从<code>reviews:v1</code>转移到<code>reviews:v3</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">istioctl replace -f samples/bookinfo/kube/route-rule-reviews-50-v3.yaml
</code></pre></div><p>注意这里使用了<code>istioctl replace</code>而不是<code>create</code>。</p>
</li>
<li>
<p>在浏览器中多次刷新<code>productpage</code>页面，大约有50%的几率会看到页面中出现带红星的评价内容。</p>
<blockquote>
<p>请注意：在目前的Envoy sidecar实现中，可能需要刷新<code>productpage</code>很多次才能看到流量分发的效果。在看到页面出现变化前，有可能需要刷新15次或者更多。如果修改规则，将90%的流量路由到v3，可以看到更明显的效果。</p>
</blockquote>
</li>
<li>
<p>当v3版本的<code>reviews</code>服务已经稳定运行后，可以将100%的流量路由到<code>reviews:v3</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">istioctl replace -f samples/bookinfo/kube/route-rule-reviews-v3.yaml
</code></pre></div><p>此时，以任何用户登录到<code>productpage</code>页面，都可以看到带红星的评价信息。</p>
</li>
</ol>
<h1 id="理解原理">理解原理</h1>
<p>在这个任务中，我们使用了Istio的带权重路由的特性将流量从老版本的<code>reviews</code>服务逐渐迁移到了新版本服务中。</p>
<p>注意该方式和使用容器编排平台的部署特性来进行版本迁移是完全不同的。容器编排平台使用了实例scaling来对流量进行管理。而通过Istio，两个版本的<code>reviews</code>服务可以独立地进行scale up和scale down，并不会影响这两个版本服务之间的流量分发。</p>
<p>想了解更多支持scaling的按版本路由功能，请查看<a href="https://istio.io/blog/canary-deployments-using-istio.html">Canary Deployments using Istio</a>。</p>
<h1 id="清理">清理</h1>
<ul>
<li>
<p>删除路由规则。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">istioctl delete -f samples/bookinfo/kube/route-rule-all-v1.yaml
</code></pre></div></li>
<li>
<p>如果不打算尝试后面的任务，请参照<a href="http://istio.doczh.cn/docs/guides/bookinfo.html#cleanup">BookInfo cleanup</a> 中的步骤关闭应用程序。</p>
</li>
</ul>
<h1 id="进阶阅读">进阶阅读</h1>
<ul>
<li>更多的内容请参见<a href="http://istio.doczh.cn/docs/concepts/traffic-management/rules-configuration.html">请求路由</a>。</li>
</ul>
  
  






<footer>
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/categories/tech/" rel="tag">Tech</a>
    </li>
    
    
  </ul>
  
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/tags/istio/" rel="tag">Istio</a>
    </li>
    
    
  </ul>
  
  
</footer>


</article>
<div class="Divider"></div>

<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://wangxin-jack.github.io/2017/11/04/istio-install_and_example/" rel="bookmark">Istio及Bookinfo示例程序安装试用笔记</a>
  </h2>
  
  <time datetime="2017-11-04T12:00:00Z">
    4 November, 2017
  </time>
  
</header>

  
  <h2 id="服务网格简介">服务网格简介</h2>
<p><strong>服务网格</strong>（Service Mesh）是为解决微服务的通信和治理而出现的一种<strong>架构模式</strong>。</p>
<p>服务网格将服务间通讯以及与此相关的管理控制功能从业务程序中下移到一个基础设施层，从而彻底隔离了业务逻辑和服务通讯两个关注点。采用服务网格后，应用开发者只需要关注并实现应用业务逻辑。服务之间的通信，包括服务发现，通讯的可靠性，通讯的安全性，服务路由等由服务网格层进行处理，并对应用程序透明。</p>
<p>让我们来回顾一下微服务架构的发展过程。在出现服务网格之前，我们在微服务应用程序进程内处理服务通讯逻辑，包括服务发现，熔断，重试，超时等逻辑，如下图所示：<br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/5-a.png" alt=""><br>
通过对这部分负责服务通讯的逻辑进行抽象和归纳，可以形成一个代码库供应用程序调用。但应用程序还是需要处理和各种语言代码库的调用细节，并且各种代码库互不兼容，导致对应用程序使用的语言和代码框架有较大限制。</p>
<p>如果我们更进一步，将这部分逻辑从应用程序进程中抽取出来，作为一个单独的进程进行部署，并将其作为服务间的通信代理，如下图所示：<br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/6-a.png" alt=""><br>
因为通讯代理进程和应用进程一起部署，因此形象地把这种部署方式称为“sidecar”（三轮摩托的挎斗）。
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/sidecar.jpg" alt="">
应用间的所有流量都需要经过代理，由于代理以sidecar方式和应用部署在同一台主机上，应用和代理之间的通讯被认为是可靠的。然后由代理来负责找到目的服务并负责通讯的可靠性和安全等问题。</p>
<p>当服务大量部署时，随着服务部署的sidecar代理之间的连接形成了一个如下图所示的网格，被称之为Service Mesh（服务网格），从而得出如下的服务网格定义。</p>
<p><em>服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求可以在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但应用程序不需要知道它们的存在。</em></p>
<p>_William Morgan <em><a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/"><em>WHAT’S A SERVICE MESH? AND WHY DO I NEED ONE?</em></a></em>                                               _</p>
<p><img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/mesh1.png" alt=""></p>
<p>了解了服务网格的基本概念，下一步介绍一下<a href="https://istio.io/">Istio</a>。Istio是来自Google，IBM和Lyft的一个Service Mesh（服务网格）开源项目，是Google继Kubernetes之后的又一大作，Istio架构先进，设计合理，刚一宣布就获得了Linkerd，nginmesh等其他Service Mesh项目的合作以及Red hat/Pivotal/Weaveworks/Tigera/Datawire等的积极响应。<br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Istio-Architecture.PNG" alt=""><br>
可以设想，在不久的将来，微服务的标准基础设施将是采用kubernetes进行服务部署和集群管理，采用Istio处理服务通讯和治理，两者相辅相成，缺一不可。</p>
<h2 id="安装kubernetes">安装Kubernetes</h2>
<p>Istio是微服务通讯和治理的基础设施层，本身并不负责服务的部署和集群管理，因此需要和Kubernetes等服务编排工具协同工作。</p>
<p>Istio在架构设计上支持各种服务部署平台，包括kubernetes，cloud foundry，Mesos等，但Istio作为Google亲儿子，对自家兄弟Kubernetes的支持肯定是首先考虑的。目前版本的0.2版本的手册中也只有Kubernetes集成的安装说明，其它部署平台和Istio的集成将在后续版本中支持。</p>
<p>从Istio控制面Pilot的架构图可以看到各种部署平台可以通过插件方式集成到Istio中，为Istio提供服务注册和发现功能。</p>
<p><img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/PilotAdapters.PNG" alt=""></p>
<p>kubernetes集群的部署较为复杂，<a href="http://rancher.com">Rancher</a>提供了kubernetes部署模板，通过一键式安装，可以大大简化kubernetes集群的安装部署过程。</p>
<p>本文的测试环境为两台虚机组成的集群，操作系统是Ubuntu 16.04.3 LTS。两台虚机的地址分别为：<br>
Rancher Server: 10.12.25.60<br>
工作节点: 10.12.25.116</p>
<p>通过Rancher安装Kubernetes集群的简要步骤如下：</p>
<h3 id="在server和工作节点上安装docker">在server和工作节点上安装docker</h3>
<p>因为k8s并不支持最新版本的docker，因此需根据该页面安装指定版本的docker<br>
<a href="http://rancher.com/docs/rancher/v1.6/en/hosts/">http://rancher.com/docs/rancher/v1.6/en/hosts/</a> ,目前是1.12版本。</p>
<pre><code>curl https://releases.rancher.com/install-docker/1.12.sh | sh
</code></pre><p>如果需要以非root用户执行docker命令，参考<a href="http://zhaohuabing.com/2018/02/09/docker-without-sudo/">如何使用非root用户执行docker命令</a>。</p>
<h3 id="启动rancher-server">启动Rancher server</h3>
<pre><code>sudo docker run -d --restart=always -p 8080:8080 rancher/server
</code></pre><h3 id="登录rancher管理界面创建k8s集群">登录Rancher管理界面，创建k8s集群</h3>
<p>Rancher 管理界面的缺省端口为8080，在浏览器中打开该界面，通过菜单Default-&gt;Manage Environment-&gt;Add Environment添加一个kubernetes集群。这里需要输入名称kubernetes，描述，然后选择kubernetes template，点击create，创建Kubernetes环境。<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Rancher.PNG" alt=""></p>
<p>点击菜单切换到kubernetes Environment，然后点击右上方的Add a host，添加一台host到kubernetes集群中。注意添加到集群中的host上必须先安装好符合要求的docker版本。</p>
<p>然后根据Rancher页面上的提示在host上执行脚本启动Rancher agent，以将host加入ranch cluster。注意脚本中包含了rancher server的地址，在host上必须可以ping通该地址。<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Rancher-add-host.PNG" alt=""></p>
<p>host加入cluster后Rancher会在host上pull kubernetes的images并启动kubernetes相关服务，根据安装环境所在网络情况不同需要等待几分钟到几十分钟不等。</p>
<h3 id="安装并配置kubectl">安装并配置kubectl</h3>
<p>待Rancher界面提示kubernetes创建成功后，安装kubernetes命令行工具kubectl</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.7.4/bin/linux/amd64/kubectl

chmod +x ./kubectl

sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre><p>登录Rancher管理界面, 将 All Environments-&gt;kubernetes-&gt;KUBERNETES-&gt;CLI create config 的内容拷贝到~/.kube/config 中，以配置Kubectl和kubernetes server的连接信息。<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Rancher-kubectl.PNG" alt=""></p>
<h2 id="安装istio">安装Istio</h2>
<p>Istio提供了安装脚本，该脚本会根据操作系统下载相应的Istio安装包并解压到当前目录。</p>
<pre><code> curl -L https://git.io/getLatestIstio | sh -
</code></pre><p>根据脚本的提示将Istio命令行所在路径加入到系统PATH环境变量中</p>
<pre><code>export PATH=&quot;$PATH:/home/ubuntu/istio-0.2.10/bin&quot;
</code></pre><p>在kubernetes集群中部署Istio控制面服务</p>
<pre><code>kubectl apply -f istio-0.2.10/install/kubernetes/istio.yaml
</code></pre><p>确认Istio控制面服务已成功部署。Kubernetes会创建一个istio-system namespace，将Istio相关服务部署在该namespace中。</p>
<p>确认Istio相关Service的部署状态</p>
<pre><code>kubectl get svc -n istio-system
</code></pre><pre><code>NAME            CLUSTER-IP      EXTERNAL-IP        PORT(S)                                                  AGE
istio-egress    10.43.192.74    &lt;none&gt;             80/TCP                                                   25s
istio-ingress   10.43.16.24     10.12.25.116,...   80:30984/TCP,443:30254/TCP                               25s
istio-mixer     10.43.215.250   &lt;none&gt;             9091/TCP,9093/TCP,9094/TCP,9102/TCP,9125/UDP,42422/TCP   26s
istio-pilot     10.43.211.140   &lt;none&gt;             8080/TCP,443/TCP                                         25s
</code></pre><p>确认Istio相关Pod的部署状态</p>
<pre><code>kubectl get pods -n istio-system
</code></pre><pre><code>NAME                             READY     STATUS    RESTARTS   AGE
istio-ca-367485603-qvbfl         1/1       Running   0          2m
istio-egress-3571786535-gwbgk    1/1       Running   0          2m
istio-ingress-2270755287-phwvq   1/1       Running   0          2m
istio-mixer-1505455116-9hmcw     2/2       Running   0          2m
istio-pilot-2278433625-68l34     1/1       Running   0          2m
</code></pre><p>从上面的输出可以看到，这里部署的主要是Istio控制面的服务，而数据面的网络代理要如何部署呢？<br>
根据前面服务网格的架构介绍可以得知，网络代理是随着应用程序以sidecar的方式部署的，在下面部署Bookinfo示例程序时会演示如何部署网络代理。</p>
<h2 id="部署bookinfo示例程序">部署Bookinfo示例程序</h2>
<p>在下载的Istio安装包的samples目录中包含了示例应用程序。</p>
<p>通过下面的命令部署Bookinfo应用</p>
<pre><code>kubectl apply -f &lt;(istioctl kube-inject -f istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml)
</code></pre><p>确认Bookinfo服务已经启动</p>
<pre><code>kubectl get services
</code></pre><pre><code>NAME          CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
details       10.43.175.204   &lt;none&gt;        9080/TCP   6m
kubernetes    10.43.0.1       &lt;none&gt;        443/TCP    5d
productpage   10.43.19.154    &lt;none&gt;        9080/TCP   6m
ratings       10.43.50.160    &lt;none&gt;        9080/TCP   6m
reviews       10.43.219.248   &lt;none&gt;        9080/TCP   6m
</code></pre><p>在浏览器中打开应用程序页面，地址为istio-ingress的External IP</p>
<p><code>http://10.12.25.116/productpage</code><br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Bookinfo.PNG" alt=""></p>
<h2 id="理解istio-proxy实现原理">理解Istio Proxy实现原理</h2>
<p>服务网格相对于sprint cloud等微服务代码库的一大优势是其对应用程序无侵入，在不修改应用程序代码的前提下对应用服务之间的通信进行接管，Istio是如何做到这点的呢？下面通过示例程序的部署剖析其中的原理。</p>
<p>如果熟悉kubernetes的应用部署过程，我们知道Bookinfo应用程序的标准部署方式是这样的：</p>
<pre><code>kubectl apply -f istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml
</code></pre><p>但从上面的部署过程可以看到，kubectl apply命令的输入并不是一个kubernetes yaml文件，而是<code>istioctl kube-inject -f istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml</code>命令的输出。</p>
<p>这段命令在这里起到了什么作用呢？通过单独运行该命令并将输出保存到文件中，我们可以查看istioctl kube-inject命令到底在背后搞了什么小动作。</p>
<pre><code>istioctl kube-inject -f istio-0.2.10/samples/bookinfo/kube/bookinfo.yaml &gt;&gt; bookinfo_with_sidecar.yaml
</code></pre><p>对比bookinfo/_with/_sidecar.yaml文件和bookinfo.yaml，可以看到该命令在bookinfo.yaml的基础上做了如下改动：</p>
<ul>
<li>
<p>为每个pod增加了一个代理container，该container用于处理应用container之间的通信，包括服务发现，路由规则处理等。从下面的配置文件中可以看到proxy container通过15001端口进行监听，接收应用container的流量。</p>
</li>
<li>
<p>为每个pod增加了一个init-container，该container用于配置iptable，将应用container的流量导入到代理container中。</p>
</li>
</ul>
<pre><code>  #注入istio 网络代理
  image: docker.io/istio/proxy_debug:0.2.10
        imagePullPolicy: IfNotPresent
        name: istio-proxy
        resources: {}
        securityContext:
          privileged: true
          readOnlyRootFilesystem: false
          runAsUser: 1337
        volumeMounts:
        - mountPath: /etc/istio/proxy
          name: istio-envoy
        - mountPath: /etc/certs/
          name: istio-certs
          readOnly: true
      #使用init container修改iptable
      initContainers:
      - args:
        - -p
        - &quot;15001&quot;
        - -u
        - &quot;1337&quot;
        image: docker.io/istio/proxy_init:0.2.10
        imagePullPolicy: IfNotPresent
        name: istio-init
</code></pre><p>从上面的分析，我们可以看出Istio的kube-inject工具的用途即是将代理sidecar注入了Bookinfo的kubernetes yaml部署文件中。通过该方式，不需要用户手动修改kubernetes的部署文件，即可在部署服务时将sidecar和应用一起部署。</p>
<p>通过命令查看pod中部署的docker container，确认是否部署了Istio代理</p>
<pre><code>kubectl get pods

NAME                              READY     STATUS    RESTARTS   AGE
details-v1-3688945616-8hv8x       2/2       Running   0          1d
productpage-v1-2055622944-cslw1   2/2       Running   0          1d
ratings-v1-233971408-8dcnp        2/2       Running   0          1d
reviews-v1-1360980140-474x6       2/2       Running   0          1d
reviews-v2-1193607610-cfhb5       2/2       Running   0          1d
reviews-v3-3340858212-b5c8k       2/2       Running   0          1d
</code></pre><p>查看reviews pod的中的container，可以看到pod中除reviews container外还部署了一个istio-proxy container</p>
<pre><code>kubectl get pod reviews-v3-3340858212-b5c8k -o jsonpath='{.spec.containers[*].name}'

reviews istio-proxy
</code></pre><p>而应用container的流量是如何被导入到istio-proxy中的呢？</p>
<p>原理是Istio proxy在端口15001进行监听，pod中应用container的流量通过iptables规则被重定向到15001端口中。下面我们进入pod内部，通过相关命令来验证这一点。</p>
<p>先通过命令行找到ratings-v1-233971408-8dcnp pod的PID，以用于查看其network namespace內的iptables规则。</p>
<pre><code>CONTAINER_ID=$(kubectl get po ratings-v1-233971408-8dcnp -o jsonpath='{.status.containerStatuses[0].containerID}' | cut -c 10-21)

PID=$(sudo docker inspect --format '{{ .State.Pid }}' $CONTAINER_ID)
</code></pre><p>可以使用nsenter命令来进入pod的network namespace执行命令。<br>
使用netstat命令可以看到istio proxy代理的监听端口15001</p>
<pre><code>sudo nsenter -t ${PID} -n netstat -all | grep 15001

tcp        0      0 *:15001                 *:*                     LISTEN
</code></pre><p>使用iptables命令可以查看到下面的规则</p>
<pre><code>sudo nsenter -t ${PID} -n iptables -t nat -L -n -v

Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
   16   960 ISTIO_REDIRECT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* istio/install-istio-prerouting */

Chain INPUT (policy ACCEPT 16 packets, 960 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 84838 packets, 7963K bytes)
 pkts bytes target     prot opt in     out     source               destination
 1969  118K ISTIO_OUTPUT  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* istio/install-istio-output */

Chain POSTROUTING (policy ACCEPT 84838 packets, 7963K bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain ISTIO_OUTPUT (1 references)
 pkts bytes target     prot opt in     out     source               destination
    0     0 ISTIO_REDIRECT  all  --  *      lo      0.0.0.0/0           !127.0.0.1            /* istio/redirect-implicit-loopback */
 1969  118K RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            owner UID match 1337 /* istio/bypass-envoy */
    0     0 RETURN     all  --  *      *       0.0.0.0/0            127.0.0.1            /* istio/bypass-explicit-loopback */
    0     0 ISTIO_REDIRECT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* istio/redirect-default-outbound */

Chain ISTIO_REDIRECT (3 references)
 pkts bytes target     prot opt in     out     source               destination
   16   960 REDIRECT   tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* istio/redirect-to-envoy-port */ redir ports 15001
</code></pre><p>从pod所在network namespace的iptables规则中可以看到，pod的入口和出口流量分别通过PREROUTING和OUTPUT chain指向了自定义的ISTIO/_REDIRECT chain，而ISTIO/_REDIRECT chain中的规则将所有流量都重定向到了istio proxy正在监听的15001端口中。从而实现了对应用透明的通信代理。</p>
<h2 id="测试路由规则">测试路由规则</h2>
<p>多次刷新Bookinfo应用的productpage页面，我们会发现该页面中显示的Book Reviews有时候有带红星的评价信息，有时有带黑星的评价信息，有时只有文字评价信息。<br>
这是因为Bookinfo应用程序部署了3个版本的Reviews服务，每个版本的返回结果不同，在没有设置路由规则时，缺省的路由会将请求随机路由到每个版本的服务上，如下图所示：</p>
<p><img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/withistio.svg" alt=""></p>
<p>通过创建一条路由规则route-rule.yaml，将请求流量都引导到Reviews-v1服务上</p>
<pre><code>apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
  name: reviews-default
spec:
  destination:
    name: reviews
  precedence: 1
  route:
  - labels:
      version: v1
</code></pre><p>启用该路由规则</p>
<pre><code>istioctl create -f route-rule.yaml -n default
</code></pre><p>再次打开productpage页面, 无论刷新多少次，显示的页面将始终是v1版本的输出，即不带星的评价内容。<br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/Bookinfo-no-star.PNG" alt=""><br>
删除该路由规则</p>
<pre><code>istioctl delete -f route_rule.yaml -n default
</code></pre><p>继续刷新productpage页面,将重新随机出现三个版本的评价内容页面。</p>
<h2 id="分布式调用追踪">分布式调用追踪</h2>
<p>首先修改安装包中的 <code>istio-0.2.10/install/kubernetes/addons/zipkin.yaml</code> 部署文件，增加Nodeport,以便能在kubernetes集群外部访问zipkin界面。</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: zipkin
  namespace: istio-system
spec:
  ports:
  - name: http
    port: 9411
    nodePort: 30001
  selector:
    app: zipkin
  type: NodePort
</code></pre><p>部署zipkin服务。</p>
<pre><code>kubectl apply -f istio-0.2.10/install/kubernetes/addons/zipkin.yaml
</code></pre><p>在浏览器中打开zipkin页面，可以追踪一个端到端调用经过了哪些服务，以及各个服务花费的时间等详细信息，如下图所示：<br>
<code>http://10.12.25.116:30001</code><br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/zipkin.PNG" alt=""></p>
<h2 id="性能指标监控">性能指标监控</h2>
<p>首先修改安装包中的 <code>istio-0.2.10/install/kubernetes/addons/grafana.yaml</code> 部署文件，增加Nodeport,以便能在kubernetes集群外部访问grafana界面。</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: istio-system
spec:
  ports:
  - port: 3000
    protocol: TCP
    name: http
    nodePort: 30002
  selector:
    app: grafana
  type: NodePort
</code></pre><p>prometheus用于收集和存储信息指标，grafana用于将性能指标信息进行可视化呈现，需要同时部署prometheus和grafana服务。</p>
<pre><code>kubectl apply -f istio-0.2.10/install/kubernetes/addons/prometheus.yaml

kubectl apply -f istio-0.2.10/install/kubernetes/addons/grafana.yaml
</code></pre><p>首先在浏览器中打开Bookinfo的页面<code>http://10.12.25.116/productpage</code>，刷新几次，以制造一些性能指标数据。</p>
<p>然后打开grafana页面查看性能指标<code>http://10.12.25.116:30002/dashboard/db/istio-dashboard</code>，如下图所示：<br>
<img src="https://img.zhaohuabing.com/in-post/istio-install_and_example/grafana.PNG" alt=""></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://istio.io/docs/">Istio官方文档</a></li>
<li><a href="http://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a></li>
<li><a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/">WHAT’S A SERVICE MESH? AND WHY DO I NEED ONE?</a></li>
<li><a href="https://thenewstack.io/hackers-guide-kubernetes-networking/">A Hacker’s Guide to Kubernetes Networking</a></li>
</ul>
  
  






<footer>
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/categories/tech/" rel="tag">Tech</a>
    </li>
    
    
  </ul>
  
  
  
  <ul class="Tags">
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://wangxin-jack.github.io/tags/istio/" rel="tag">Istio</a>
    </li>
    
    
  </ul>
  
  
</footer>


</article>
<div class="Divider"></div>

<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://wangxin-jack.github.io/2017/11/03/hello-world/" rel="bookmark">Welcome to Zhaohuabing Blog</a>
  </h2>
  
  <time datetime="2017-11-04T00:00:00Z">
    4 November, 2017
  </time>
  
</header>

  
  <blockquote>
<p>“Yeah It's on. ”</p>
</blockquote>
<h2 id="hello-world">Hello World!</h2>

  
  







</article>
<div class="Divider"></div>


<nav>
  
  
  <a class="Pagination Pagination--right u-clickable" href="https://wangxin-jack.github.io/page/2/" rel="next">Next »</a>
  
</nav>




      </div>
    </div>
  </main>
  
<footer class="Footer">
  <div class="u-wrapper">
    <div class="u-padding">
      Except where otherwise noted, content on this site is licensed under a a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license"> Creative Commons Attribution 4.0 International License</a>.
    </div>
  </div>
</footer>


</body>
</html>
